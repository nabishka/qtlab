#include "mainwindow.h"
#include "ui_mainwindow.h"
#include <QMessageBox> // adding class to use pop-ups
#include <QTableWidgetItem> // adding class to use TableWidget
#include <QRandomGenerator> // for using random
#include <limits>

MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
{
    ui->setupUi(this);

    ui->table_with_values_array->setColumnCount(0); //даем кол-ву колонок значение  ноль так как пользователь не выбрал с чем работать
    ui->spin_row_value_tables->setMaximum(0); //ставим ограничение на кол-во строк ноль чтобы пользователь не мог увеличивать их количество
    ui->table_count->setColumnCount(0); // даем кол-ву колонок в таблице вывода строк ноль так как пользователь не выбрал с чем работать

    //очистка значений ответов
    ui->label_max_answer->clear();
    ui->label_mean_answer->clear();
    ui->label_min_answer->clear();
    ui->label_answer_perimeter->clear();
    ui->label_answer_square->clear();
    ui->label_meaning_answer_of_number_of_occurences->clear();
    ui->label_meaning_rare_value->clear();
}

MainWindow::~MainWindow()
{
    delete ui;
}

void MainWindow::on_spin_row_value_tables_valueChanged(int arg1) //изменение значения в спин боксе
{
    if(!geometry_program and !dinamic_program)
    {
        QMessageBox::information(this, "Ошибка", "Выберите проект");
    }
    ui->table_with_values_array->setRowCount(arg1); // создаем столько строк  столько сколько значение спина
    size = arg1;//создаем размер сайз равный количеству строк для использования в массивах
    ui->label_max_answer->clear(); //очищает значение максимального числа в массиве
    ui->label_mean_answer->clear(); //очищает значение среднего числа в массиве
    ui->label_min_answer->clear();  //очищает значение минимального числа в массиве
    ui->label_meaning_answer_of_number_of_occurences->clear();  //очищает значение кол-ва найденных элементов при поиске
    ui->label_answer_perimeter->clear();
    ui->label_answer_square->clear();
    ui->table_count->setRowCount(size_of_count = 0);//очищает таблицу найденных значений
    ui->label_meaning_rare_value->clear(); //очищает значение вывода самого редкого числа найденного в массиве

}

void MainWindow::on_press_button_min_value_clicked()//поиск минимального значения
{
    if (dinamic_program) // if dinamic programm checked
    {
        mining = true; //показывает что последующие изменения вызваныпоиском минимального значения
        if(sorted)    //если массив отсортирован то просто считываем первое значение в таблице
        {
            QTableWidgetItem *item = ui->table_with_values_array->item(0,0);    // создаем указатель на ячейку памяти которую занимает нулевая ячейка таблицы
            QString str = item->text(); // создаем строку которой даем значение текста,хранящегося в памяти по указателю созданному ранее
            ui->label_min_answer->setText(str); //даем значению строки минимального ответа значение нулевой ячейки отсорртированного массива

        }else
        {
            bool error = false; // создаем булевую переменную для проверки перевод в число данных вводимых в ячейки
            double *mas = new double [size]; //создаем динамический массив
            read_array(mas, size, &error);   //задаем динамический массив
            if (error)   //если ошибка чтения массива
            {
                QMessageBox::information(this,"Ошибка","Таблица заполнена неккоректно",QMessageBox::Ok); //выводит ошибку значения в массиве
                delete [] mas;   //удаляем память которую занимал созданный массив
                mas=nullptr; //зануляем значение указателя, чтоб при обращении к нему программа не выдавала ошибку
                mining = false;
                return;  //выходим из функции, чтоб программа не искала минимальное значение и не выдавала ошибок
            }
            // ПОИСК МИН ЗНАЧЕНИЯ
            double min = mas[0];    //считываем значение первого элемента в таблице
            for (int i = 1; i< size; i ++)  // создаем цикл который пройдется по всем индексам
            {
                if(mas[i]<min)  //если значение текущего элемента массива меньше значения предыдущего
                {
                    min = mas[i];   // присваиваем значение минимального числа новонайденному минимальному числу
                }
            }
            //КОНЕЦ ПОИСКА МИНИМАЛЬНОГО ЗНАЧЕНИЯ
            if(qIsInf(min) or qIsNaN(min))  //проверка на бесконечность ии нечисло
            {
                QMessageBox::information(this,"Ошибка","Переполнение или не является числом",QMessageBox::Ok);  //выводим пользователю ошибку

            } else  //иначе если число не являлось бесконечностью или нечислом
            {
                ui->label_min_answer->setNum(min);  // вводим в строку ответа поиска минимального числа значения минимальное число
            }
            delete[] mas;   //удаляем использованный массив, чтобы не использовать лишнюю память
            mas = nullptr;  //зануляем указатель чтоб у программы не было ошибок при последующих ошибочных вызовах указателя
        }
        mining = false;  //показывает что изменения вызванные поиском минимального значения закончились
    }
    else
    {
        QMessageBox::information(this, "Ошибка", "Выберите проект работы с динамическим массивом");
    }
}

void MainWindow::read_array(double *mas, int size, bool *error) //считывание значений в таблице и возвращение готового массива со значениями
{
    if (dinamic_program)
    {
        *error = false; //изначально значение ошибки присваиваем ноль на случай если в программу отправили неправильное значение ошибки
        bool scrol = false; //переменная показывает что мы еще не спускались к перовму ошибочному элементу в табилце
        for (int i=0; i < size; i++)    //создаем цикл который пройдется по всем индексам ячеек таблицы
        {
            QTableWidgetItem *item = ui->table_with_values_array->item(i,0);    //создаем указатель на памятть в которой хранится итое значение ячейки
            if(item==nullptr) //если указатель показывает что память для ячейки не была создана
            {
                item = new QTableWidgetItem; // мы выделяем память для значений пустой ячейки и присваиваем ее адрес указателю
                ui->table_with_values_array->setItem(i, 0, item); //устанавливаем в значение данной ячейки память на которую указывает указатель, чтобы эта ячейка имела значение новой пустой ячейки
            }
            QString text = item->text();    //считываем значение текста из текущей ячейки в созданную переменную строки
            bool ok = false;    //создаем булевую переменную для проверки перевода текста текущей ячейки в дабл
            double value = text.toDouble(&ok);  //создаем переменную которой даем значение текста текущей ячейки преобразованное в дабл, добавляя изменение булевой переменной для проверки корректности перевода
            if(ok)  //если текст перевелся в число корректно
            {
                mas[i] = value; //значению массива  присваиваем значение ячейки совпадающей по индексу
                item->setBackground(Qt::white); //изменяем цвет текущей ячейки с помощью указателя на память в которой хранятся все значения ячейки
            }
            else    //иначе если текст не перевелся в число корректно
            {
                *error = true;  //значению ошибки присваиваем значение истино
                item->setBackground(Qt::red); //изменяем цвет ячейки на красный, кстати для этого мы выделяли память для пустых ячеек
                if (!scrol) //если к ошибке не прокручивалось
                {
                    ui->table_with_values_array->scrollToItem(ui->table_with_values_array->item(i,0)); //прокручиваем к первой ошибке
                    scrol = true; // скролинг был совершен
                }
            }
        }
        if(ui->table_with_values_array->rowCount()==0)  //если у таблицы нет строк
        {
            *error = true; // возвращает ошибку
            QMessageBox::information(this,"Ошибка","Таблица не заполнена",QMessageBox::Ok);
        }
    }
    else
    {
        QMessageBox::information(this, "Ошибка", "Выберите проект работы с динамическим массивом");
    }
}

void MainWindow::on_table_with_values_array_itemChanged(QTableWidgetItem *item) //вызывается при изменении данных в ячейке таблицы ввода
{
    if(!searched and !randoming and !sorting and !consting and !mining and!meaning and !maxing) //если производится поиск или рандом или сортировка то не включается,так как эти изменения не могут дать ложные значения ячейкам
    {
        sorted=false; //присваивает общей переменной сортировке значени ложь
        ui->label_max_answer->clear(); //очищает значение максимального числа в массиве
        ui->label_mean_answer->clear(); //очищает значение среднего числа в массиве
        ui->label_min_answer->clear();  //очищает значение минимального числа в массиве
        ui->label_meaning_rare_value->clear(); //очищает значение вывода самого редкого числа найденного в массиве
        ui->label_meaning_answer_of_number_of_occurences->clear();  //очищает значение кол-ва найденных элементов при поиске
        ui->table_count->setRowCount(size_of_count = 0);//стираем значение таблицы вывода значений
        //первый способ измения цвета при изменении ячейки в таблице
        QString text = item->text();    //считываем значение измененной ячейки
        bool ok = false;    //создаем булевую переменную для проверки перевода текста измененной ячейки в дабл
        double value = text.toDouble(&ok);  //проверяем является ли изменения в ячейке числом
        if(ok)  //если да
        {
            item->setBackground(Qt::white); //изменяем цвет текущей ячейки с помощью указателя на память в которой хранятся все значения ячейки
        }
        else    //если нет
        {
            item->setBackground(Qt::red); //изменяем цвет ячейки на красный, кстати для этого мы выделяли память для пустых ячеек при инициализации данной функции
        }
        Q_UNUSED(value);  //показываем что переменная вэлъю не используется
        //второй способ просто вызываем считывние всего массива при изменении данных в ячейке. теоретически он хуже так как занимает больше памяти потому что при считывании всего массива выделяется память на каждую ячейку в массиве а не только на изменнную
        //    double *mas = new double[size]; //создаем динамический массив размером в количество строк
        //    bool error = false; //создаем переменную так как наша функция является общей и в других случаях нужно проверять на ошибку, поэтому и здесь используем ее так как в функцию надо отправлять три начения
        //    read_array(mas,size,&error);    //используем функцию считывания массива
        //    delete [] mas;  //удаялем созданный ранее массив, чтоб он не занимал памяти
        //    mas = nullptr; //зануляем значение указателя
        //    Q_UNUSED(item); //указываем что данная переменная не используется в функции
    }
}

void MainWindow::on_press_button_rundom_clicked()   //использование рандома
{
    if (dinamic_program or geometry_program)
    {
        randoming =true; //даем глобальной переменной значение истины, чтобы программа не проверяла изменения значения они вызваны программой рандом
        sorted=false;   //присваиваем значению сортировки таблицы значение ложь
        //очищаем раннее выведенные значения так они уже не актуальны
        ui->label_max_answer->clear();
        ui->label_mean_answer->clear();
        ui->label_meaning_rare_value->clear();
        ui->label_min_answer->clear();
        ui->label_answer_perimeter->clear();
        ui->label_answer_square->clear();
        ui->label_meaning_answer_of_number_of_occurences->clear();
        ui->table_count->setRowCount(size_of_count = 0);//стираем таблицу найденных значений
        //конец очистки
        for (int i=0; i<size;i++)//создаем цикл
        {   //считываем значение ячеек
            QTableWidgetItem *item = ui->table_with_values_array->item(i,0);
            if(item==nullptr)
            {
                item = new QTableWidgetItem;
                ui->table_with_values_array->setItem(i, 0, item);
            }
            //int value = QRandomGenerator::global()->bounded(101);  //создаем переменную которой присваиваем значение рандомного числа от нуля до ста
            int value = rand()%1000;
            item->setBackground(Qt::white); //присваиваем ячейке белый цвет так как в ней будет точно число сгенерированное рандомом
            QString str;    //создаем строку
            str.setNum(value);  //переводим значение сгенерированного числа в строку
            item->setText(str); //добавляем ячейке значение введенной строки
        }
        if (ui->table_with_values_array->columnCount()==2)
        {
            for (int i=0; i<size;i++)//создаем цикл
            {   //считываем значение ячеек
                QTableWidgetItem *item = ui->table_with_values_array->item(i,1);
                if(item==nullptr)
                {
                    item = new QTableWidgetItem;
                    ui->table_with_values_array->setItem(i, 1, item);
                }
                //int value = QRandomGenerator::global()->bounded(101);  //создаем переменную которой присваиваем значение рандомного числа от нуля до ста
                int value = rand()%1000;
                item->setBackground(Qt::white); //присваиваем ячейке белый цвет так как в ней будет точно число сгенерированное рандомом
                QString str;    //создаем строку
                str.setNum(value);  //переводим значение сгенерированного числа в строку
                item->setText(str); //добавляем ячейке значение введенной строки
            }
        }
        randoming = false;  //передает что функция рандом закончилась и последующие изменения в ячейках не связаны с ней
        //   замер времени
        //   clock_t start = clock();
        //   on_press_button_gnome_clicked();
        //   clock_t end = clock();
        //   double sec = (double)(end-start)/CLOCKS_PER_SEC;
        //   ui->label_max_answer->setNum(sec);
        //   if(sec<5)
        //   {
        //       size+=1000;
        //       ui->spin_row_value_tables->setValue(size);
        //       on_press_button_rundom_clicked();
        //   }else
        //   {
        //       ui->label_mean_answer->setNum(size);
        //   }
    }
    else
    {
        QMessageBox::information(this, "Ошибка", "Выберите проект ");
    }
}

void MainWindow::on_press_vutton_max_value_clicked() //нахождение максимума
{
    if (dinamic_program)
    {
        maxing = true;
        if(sorted)    //если массив отсортирован то просто считываем первое значение в таблице
        {
            QTableWidgetItem *item = ui->table_with_values_array->item(size-1,0);    // создаем указатель на ячейку памяти которую занимает последняя ячейка таблицы
            QString str = item->text(); // создаем строку которой даем значение текста,хранящегося в памяти по указателю созданному ранее
            ui->label_max_answer->setText(str); //даем значению строки максимального ответа значение нулевой ячейки отсортированного массива

        }else
        {
            ui->label_max_answer->clear();  //очищаем предыдущее значение максимума
            bool error = false; // создаем переменную ошибки считывания данных таблицы
            double *mas =new double[size]; // создаем массив размером в количество строк таблицы
            read_array(mas,size,&error); // считываем массив
            if (error) // если массив введен неккоректно
            {
                QMessageBox::information(this,"Ошибка","Таблица заполнена неккоректно",QMessageBox::Ok);    //выводим ошибку
                delete [] mas;  //удаляем массив
                mas=nullptr;    //зануляем значение указателя на массив
                maxing = false;
                return; //выход из функции
            }
            double max = mas[0];    //создаем переменную для хранения максимального значения и присваиваем ей значение перовй ячейки
            for (int i = 1; i< size; i ++)  //создаем цикл с второго значения ячейки до последнего
            {
                if(mas[i]>max)  //если текущее число больше предыдущего
                {
                    max = mas[i];   //создаем новое максимальное число
                }
            }
            if(qIsInf(max) or qIsNaN(max))  //проверка на нечисло и бесконечность
            {
                ui->label_max_answer->clear();
                QMessageBox::information(this,"Ошибка","Переполнение или не является числом",QMessageBox::Ok);

            } else
            {
                ui->label_max_answer->setNum(max);  //вывод максимального числа если все предыдущие действия корректны
            }
            delete [] mas;  //удаление массива
            mas = nullptr;  //зануление указателя на массив
        }
        maxing = false;
    }
    else
    {
        QMessageBox::information(this, "Ошибка", "Выберите проект работы с динамическим массивом");
    }
}

void MainWindow::on_press_button_arithmetic_mean_clicked() //нахождение сред арфим
{
    if (dinamic_program)
    {
        meaning = true;
        bool error = false; // создание переменной ошибки
        double *mas = new double[size]; //создание массива
        read_array(mas,size,&error);    //чтение массива
        if (error)  //если чтение прошло некорректно выводит ошибку и удаляет массив зануляя указатель и выходя из функции
        {
            QMessageBox::information(this, "Ошибка", "Таблица заполнена некорректно!");
            delete [] mas;
            mas=nullptr;
            meaning = false;
            return;
        }
        //поиск среднего арифмитического
        double sum = 0; //выделяем память для значения суммы всех чисел и присваиваем переменной значение ноль
        double arithmetic_mean = 0; // создаем переменную для значения срежнего арифмитического
        for(int i = 0; i < size; i++)   //создаем цикл проходящий по данным массива
        {
            sum += mas[i];  //добавляем к сумме ее предыдущее значение и значение текущего элемента
        }
        arithmetic_mean = sum/size; //среднее арифмитическое равно сумме элементов деленной на количество элементов
        if(qIsInf(arithmetic_mean) or qIsNaN(arithmetic_mean)) // проверка не получилось ли у нас не число или бесконечность
        {
            QMessageBox::information(this,"Ошибка","Переполнение или не является числом",QMessageBox::Ok);  //вывод ошибки

        } else  //иначе если все прошло корректно
        {
            ui->label_mean_answer->setNum(arithmetic_mean); //выводим значение сред. арифм-ого
        }
        delete[] mas;   //удаляю массив
        mas=nullptr;    //зануляю указатель чтоб к нему нельзя было обратиться
        meaning = false;
    }
    else
    {
        QMessageBox::information(this, "Ошибка", "Выберите проект работы с динамическим массивом");
    }
}

void MainWindow::write_array(double *mas, int size) //вывод полученного массива
{
    for(int i = 0;i<size;i++)   //проход по всем индексам массива
    {
        QTableWidgetItem *item = ui->table_with_values_array->item(i,0);    //создание указателя на память в которой хранятся значения ячейки
        if(item == nullptr) // если память на значение ячейки не была выделена
        {
            item = new QTableWidgetItem;    //выделяем память для указателя
            ui->table_with_values_array->setItem(i, 0, item);   //устанавливаем в значение ячейки указатель
        }

        QString text; // выделяем память для хранения строки
        text.setNum(mas[i]); //присваиваем строке значение элемента массива переводя в строку
        item->setText(text);    //вывод строки в значение текущей ячейки
    }
}

void MainWindow::on_press_button_hairbrush_clicked()    //сортировка расческа
{
    if (dinamic_program)
    {
        sorting = true; // передаем значение происходят ли последующие изменения в ячейках из-за сортировки
        //функция реализуется только в тому случае если до нее массив не был отсортирован
        if(!sorted){
            ui->label_meaning_answer_of_number_of_occurences->clear();
            ui->table_count->setRowCount(size_of_count = 0);//таблица найденных значений опустошение
            //ПРЕДУПРЕЖДЕНИЕ О ВРЕМЕНИ
            bool error = false; //создание бул переменной на проверку корректности полседующего считывания массива
            double *mas = new double[size]; //создание динамического массива
            read_array(mas, size, &error);  //считывание динамического массива
            if(error)   //если считывание прошло неккоректно
            {
                QMessageBox::information(this, "Ошибка", "Таблица заполнена некорректно!"); //вывод ошибки
                delete [] mas;  //удаление массива
                mas=nullptr;    //зануление указателя
                sorting=false;
                return; //выход из функции
            }
            int step = size;    //создание шага присваивая ему размер массива
            while (step >= 1 )  //пока шаг больше одного и ок истина
            {
                if (step>=1) //если шаг больше одного
                {
                    step = int(step/1.247); //делим шаг на фактор
                }
                int i = 0;  //значению индекса присваиваем ноль
                while (i + step < size) //пока сумма шага и индекса меньше размера
                {
                    if (mas[i] > mas[i+step])   //если текущий элемент массива больше элемента массива по индексу суммы текущего и шага
                    {
                        double t = mas[i];  // создаем переменную которой присваиваем значение текущего элемента
                        mas[i] = mas[i+step]; //элементу ближе к началу массива присваиваем значение элемента ближе к концу
                        mas[i+step] = t;    //элементу ближе к концу присваиваем значение элемента ближе к началу
                    }
                    i++;    //индекс увеличивается на один
                }
            }
            write_array(mas,size);  //выводим отсортированный массив
            delete [] mas;  //удаляем массив
            mas = nullptr;  //зануляем указатель
            sorted = true;  //показываем что массив сортировался
        }
        sorting = false; //сортировка закончена
    }
    else
    {
        QMessageBox::information(this, "Ошибка", "Выберите проект работы с динамическим массивом");
    }
}

void MainWindow::on_press_button_gnome_clicked()    //сортировка гномом
{
    if (dinamic_program)
    {
        bool ok = true; // переменная для обозначения согласен ли пользователь ждать при долгоц работе программы
        if(size>68500)
        {
            QMessageBox msg;    //создаем месадж бокс
            msg.setWindowTitle("Предупреждение");
            msg.setText("Процесс займет больше пяти секунд,хотите продолжить?");    //вводим в него текст
            msg.setStandardButtons(QMessageBox::Yes | QMessageBox::No);     //создаем набор кнопок для ответа пользователя
            int ret=msg.exec();    // создаем переменную которой даем значение вывода окна
            switch (ret) //если переменная рет
            {
            case QMessageBox::No: //указывает на нажатие кнопки нет
                ok=false;   //пользователь не согласен
            }
        }
        sorting = true; // передаем значение происходят ли последующие изменения в ячейках из-за сортировки
        if(!sorted and ok)
        {
            ui->label_meaning_answer_of_number_of_occurences->clear();
            ui->table_count->setRowCount(size_of_count = 0);//стерание массива вывода функции
            //ПРЕДУПРЕЖДЕНИЕ О ВРЕМЕНИ
            bool error = false; // для проверки коррекности заполнености таблицы создаем булевую переменную
            double *mas = new double[size]; // создаем массив
            read_array(mas, size, &error);  // вызываем функцию считывания массива передавая ей аргументы функции
            if(error)   // если ошибка считывания функции
            {
                QMessageBox::information(this, "Ошибка", "Таблица заполнена некорректно!"); // создаем сообщение об ошибке
                delete [] mas;  //удаляем созданный массив чтоб не занимал память
                mas=nullptr;    //зануляем указатель
                sorting=false;
                return; //вызодим из функции
            }
            //ПЕРВЫЙ СПОСОБ НА УВЕЛИЧЕНИЕ ПОЧЕМУ ТО НЕ КОРРЕКТНО РАБОТАЕТ
            //        int i = 0;  // создаем переменную, которую будем использовать для указания текущего индекса массива
            //        int j = 2;  // создаем переменную которая будет указывать на переменную массива до которой в прошлый раз сортировка шла корректно
            //        while(i<size-1)   //пока индекс меньше размера массива
            //        {
            //            if(mas[i+1]>mas[i]) //если след элемент больше предыдущего
            //            {
            //                i=j-1;    // то переходим к последнему элементу до которого все было корректно
            //                j++;    //последний корректный  элемент переводим на один больше
            //            }else   //ели след меньше предыдущего то меняем их местами
            //            {
            //                double f = mas[i];    //создаем переменную для обмена значений следующего и текущего элемента
            //                mas[i]=mas[i+1];    //текущему элементу даем значение следующего
            //                mas[i+1] = f;   //следующему элементу даем значение текущего
            //                i = i-1;    //уменьшаем индекс на один чтоб проверить корректность нахождения ныне измененного элемента с другими до него измененными элементами
            //                if(i==0) // если индекс элемента равен нулю снова делаем проверку для нулевого элемента (она необходима чтоб не выйти за массив и чтобы значение первого элемента было корректно
            //                {
            //                    if(mas[i+1]>mas[i]) //если все верно мы переходим к последней "стоп точке"
            //                    {
            //                        i=j-1;    // i assign last correct number
            //                        j++;    //last correct number assign i
            //                    }else
            //                    {
            //                        double f = mas[i];    //create f
            //                        mas[i]=mas[i+1];
            //                        mas[i+1] = f;
            //                        i = j-1;
            //                        j++;
            //                    }
            //                }
            //            }
            //        }
            int i = 1;  //создаем переменную равную индексу текущего элемента
            int j = 2; // создаем переменную равную индексу элемента до которого все элементы в массивеее отсортированы
            while(i<size)
            {
                if(mas[i-1]<mas[i]) //если элементы идут по возрастанию
                {
                    i=j;    //переходим к последнему элементу до которого все корректно
                    j++;    //последний элемент до которого все корректно становится на один больше
                } else  //если предыдущий элемент больше текущего
                {
                    double f = mas[i-1];    //создаем переменную для значения предыдущего
                    mas[i-1] = mas[i];  //текущему присваиваем значение предыдущего
                    mas[i] = f; //предыдущему присваиваем значение текущего
                    i--;    //уменьшаем индекс на 1 чтоб проверить корректность нахождения текущего элемента относительно предыдущих
                    if (i==0)   //если уменьшенный индекс равен нулю значит ранее нет никаких элементтов и след цикл выйдет за массив
                    {
                        i=j;    //переходим к "стоп точке"
                        j++;    //увеличиваем "стоп точку"
                    }
                }
            }
            write_array(mas,size);  //выводим массив на таблицу
            delete [] mas;  //удаляем массив
            mas=nullptr;    //зануляем указатель
            sorted = true;  //переменная отсортирован присваиваем правда
        }

        sorting = false; //передает значение что сортировка закончилась
    }
    else
    {
        QMessageBox::information(this, "Ошибка", "Выберите проект работы с динамическим массивом");
    }
}

void MainWindow::on_press_button_bubble_clicked() //сортировка пузырьком
{
    if (dinamic_program)
    {
        sorting = true; // передаем значение происходят ли последующие изменения в ячейках из-за сортировки
        bool ok = true; // переменная для обозначения согласен ли пользователь ждать при долгоц работе программы
        if(size>68500)
        {
            QMessageBox msg;    //создаем месадж бокс
            msg.setWindowTitle("Предупреждение");
            msg.setText("Процесс займет больше пяти секунд,хотите продолжить?");    //вводим в него текст
            msg.setStandardButtons(QMessageBox::Yes | QMessageBox::No);     //создаем набор кнопок для ответа пользователя
            int ret=msg.exec();    // создаем переменную которой даем значение вывода окна
            switch (ret) //если переменная рет
            {
            case QMessageBox::No: //указывает на нажатие кнопки нет
                ok=false;   //пользователь не согласен
            }
        }
        if(!sorted and ok) //если ранее не был отсортирован
        {
            ui->label_meaning_answer_of_number_of_occurences->clear();
            ui->table_count->setRowCount(size_of_count = 0);//удаление массива вывода
            size_of_count=0;
            bool error = false; // на случай ошибок некоректного вода в таблицу
            double *mas = new double[size]; //создаем пустой массив
            read_array(mas, size, &error);  //считываем данные таблицы и сохраняем их в массив
            if(error)   //если таблица заполнена некорректно выводим ошбику,удаляем и зануляем указатель
            {
                QMessageBox::information(this, "Ошибка", "Таблица заполнена некорректно!");
                delete [] mas;
                mas=nullptr;
                sorting=false;
                return;
            }
            for(int i=0; i<size; i++)   //проходим по индексам массива
            {
                for(int j=0; j<i; j++)  //проходим по индексам до текущего индекса
                {
                    if(mas[i] < mas[j]) //если текущий элемент меньше элемента до него, то меняем их местами
                    {
                        double t = mas[i];  //переменной т присваиваем текущего элемента
                        mas[i] = mas[j];    //переменной текущего элемента присваиваем значение элемента до него
                        mas[j] = t; //перементу до текущего присваиваем значение текущего
                    }
                }
            }
            write_array(mas,size);  //выводим массив на таблице
            delete[] mas;   //очищаем массив
            mas=nullptr;    //зануляем указатель
            sorted = true;  // переменная сортирован = истина
        }
        sorting = false; // передаем значение что сортировка закончилась
    }
    else
    {
        QMessageBox::information(this, "Ошибка", "Выберите проект работы с динамическим массивом");
    }
}

bool MainWindow::isSorted(double *mas, int size)    //функция проверки отсортирован ли массив для сортировки обезьянкой
{
    while (--size > 0)
        if (mas[size] < mas[size - 1])
            return false;
    return true;
}

void MainWindow::on_press_button_monkey_clicked() //сортировка обезьянкой
{
    if (dinamic_program)
    {
        ui->label_meaning_answer_of_number_of_occurences->clear();
        ui->table_count->setRowCount(size_of_count = 0);//стирание таблицы вывода
        size_of_count=0;
        if (size>5) // если размер больше пяти выводим ошибку и выходим из функции
        {
            QMessageBox::information(this,"Error","Слишком много элементов для данного метода сортировки");
            return;
        }
        bool error = false; //переменная ошибки корректности заполнения массива = ложь
        double *mas = new double[size]; // создаем массив
        read_array(mas, size, &error);  // вызываем функцию считывания массива
        if(error)   //если массив заполнен неккоректно
        {
            QMessageBox::information(this, "Ошибка", "Таблица заполнена некорректно!"); //выводим ошибку
            delete [] mas;  //удаялем массив
            mas=nullptr;    //зануляем указатель
            return; //выходим из функции
        }
        while (!isSorted(mas, size)and size<=5) //пока массив не отсортирован
        {
            double t;   //переменная значения элемента
            int v;  // переменная индекса элемента
            for (int i = 0; i < size; i++)  //проходим по элементам массива
            {
                v=rand()%size;  //индексу элемента присваиваем рандомное значение
                t=mas[v];   // переменной значения элемента присваиваем значение рандомного элемента
                mas[v]=mas[i];  // значению рандомного элемента присваиваем значение текущего
                mas[i]=t;   // значению текущего элемента присваиваем значение рандомного
            }
        }
        write_array(mas,size);  //выводим массив
        delete [] mas;  //удаляем массив
        mas=nullptr;    //зануляем указатель
        sorted = true;  //значение сортирован = истина
    }
    else
    {
        QMessageBox::information(this, "Ошибка", "Выберите проект работы с динамическим массивом");
    }
}

void MainWindow::sortQuick(double *mas, int size)   //функция быстрой сортировки
{

    int l = 0;  //индекс первого элемента
    int r = size - 1;   //индекс последнего  элемента
    double middle = mas[size/2];    //значение среднего элемента
    do  // делать ... пока индекс начинавшийся с начала меньше или равен индексу начинавшемуся с конца
    {
        while(mas[l] < middle)  //пока значение текущего элемента начинавшего с начала меньше значения среднего элемента
        {
            l++;    //индекс текущего элемента начинавшего с начала увеличиваем на оодин
        }
        while(mas[r] > middle)  //пока значение текущего элемента начинавшего с конца больше значения среднего элемента
        {
            r--;    //индекс текущего элемента начиная с конца уменьшаем на один
        }
        if (l <= r) //если индекс начинавший с начало меньше или равне индексу начинавшего с конца
        {
            double t = mas[l];  //переменной т присваиваем значение элемента начинавшего с начала
            mas[l] = mas[r];    //элементу начинавшего с начала присваиваем ззначение элемента начинавшего с конца
            mas[r] = t; //элементу начинавшего с конца
            //count++;
            l++;    //индекс начинавшийся с начала плю один
            r--;    //индекс начинавшийся с конца минус один
        }
    }while(l <= r);
    if (r > 0)  // если индекс начинавшийся с конца больше нуля
    {
        sortQuick(mas, r + 1);  // вызываем функцию быстрой сортировки задавая значеение длины массива на один больше
    }
    if (l < size)   //если индекс начинавшийся с начала меньше размера массива
    {
        sortQuick(&mas[l], size - l);   // вызываем функцию быстрой сортировки задавая адрес элемента начинавшего с начала и значение длины массива меньше на индекс начинавшийся с начала
    }
}

void MainWindow::on_press_button_fast_clicked() // быстрая сортировка
{
    if (dinamic_program)
    {
        sorting = true; // передаем значение происходят ли последующие изменения в ячейках из-за сортировки
        if(!sorted) //если массив ранее не отсортирован
        {
            ui->label_meaning_answer_of_number_of_occurences->clear();
            ui->table_count->setRowCount(size_of_count = 0);//стирание массива вывода
            bool error = false; // переменная для проверки ошибок корректности заполнения ячеек в таблице
            double *mas = new double[size];     // создаем ммассив
            read_array(mas, size, &error);  // вызов функции чтения данных в таблице и заполнения массива
            if(error)   //если таблица была заполнена неккоректно то выдает ошибку, удаляет массив, зануляет указатель и выходит из функции
            {
                QMessageBox::information(this, "Ошибка", "Таблица заполнена некорректно!");
                delete [] mas;
                mas=nullptr;
                return;
            }
            sortQuick(mas, size);   //вызывает функцию быстрой сортировки
            write_array(mas,size);  //записывает значения отсортированного массива в таблицу
            delete[] mas;   //удаялет массив
            mas = nullptr;  //зануляет указатель
            sorted = true;  //значение сортировки = истина
        }
        sorting = false; // передает значение что сортировка окончена
    }
    else
    {
        QMessageBox::information(this, "Ошибка", "Выберите проект работы с динамическим массивом");
    }
}

void MainWindow::on_press_button_search_clicked() //функция поиска
{
    if (dinamic_program)
    {
        ui->table_count->setRowCount(size_of_count = 0);
        bool scrol = false; // показывает что еще не скролился к первому найденному значению
        counting = true; //измененияя вызванные поиском начались
        searched = true; //значение ищет равно истина чтобы другие функции не реагировали на изменения создаваемы поиском
        bool ok;    // создаем переменную для проверки корректности введенного в строку поиска
        double search = ui->lineEdit_of_search->text().toDouble(&ok);   //считывание введенного в строку поиска и перевод в значение числа
        if (!ok) // если преобразование прошло неккоректно то выдаем ошибку и выходим из функции
        {
            QMessageBox::information(this, "Ошибка", "Некорреткное искомое значение!");
            searched = false;
            counting = false;
            return;
        }
        bool error = false; //переменаая для проверки корреткности заполнения массива
        double *mas = new double[size]; //создание массива
        read_array(mas, size, &error);  //чтение массива
        if(error)   //если массив заполнен неккоректно выводит ошибку,удаляет массив, азнуляет указатель, выходит из функции
        {
            QMessageBox::information(this, "Ошибка", "Таблица заполнена некорректно!");
            delete [] mas;
            mas=nullptr;
            searched=false;
            counting = false;//изменения вызванные поиском закончились
            return;
        }
        int count = 0; // количество нахождений
        if (!sorted)    //если массив не отсортирован то используем линейный поиск
        {
            for(int i =0; i<size;i++)   //проходим переменной i по всем индексам массива
            {
                if(qFuzzyCompare(mas[i],search))    // если значение текущего элемента массива совпадает с искомым
                {
                    if (!scrol) //если к ошибке не прокручивалось
                    {
                        ui->table_with_values_array->scrollToItem(ui->table_with_values_array->item(i,0)); //прокручиваем к первой ошибке
                        scrol = true; // скролинг был совершен
                    }
                    count++;    //кол-во нахождений плюс один
                    int found_row=i+1;  //создаем значение найденной строки и присваиваем ему значение текущего индекса плюс один так как таблица начинает нумерацию  с единицы а не нуля
                    QString str;    // создаем переменную для хранения значения найденной строки в типе строки
                    str.setNum(found_row);  //сохраняем в переменную значение номера найденной строки преобразовывая его в строку
                    ui->table_with_values_array->item(i, 0)->setBackground(Qt::green);  //выделяем ячейку в таблице зеленным цветом
                    tablment(&str); //добавляем в таблицу строку элемента
                }
            }
        }else   //если массив был отсортирован
        {
            //бинарный поиск
            int a = 0; // значение индекса  первого элемента массива
            int b = size-1; //индекс конечного элемента в массиве
            int midle;  //переменная индекса середины массива
            while (a<b) // пока начальное значение массива больше конечного значения массива мы выбираем часть массива в котрой есть искомое число
            {
                midle = (a+b)/2;    //середине массива присваиваем значение длины массива поделенной на двое
                if(mas[midle]>search) //если элемент по середине массива больше искомого значение
                {
                    b = midle; //конечному  индексу массива присваиваем значение индекса текущеей середины массива
                } else  //если значение элемента по середине массива меньше искомого
                {
                    a = midle + 1;  // то индексу начального значение массива присваиваем значение индекса текущей середины массива
                }
            }
            b--;    // отнимаем от значения индекса конца поиска в массиве один
            if (qFuzzyCompare(mas[b],search))   //если элемент под индексом б совпадает с искомым значением
            {
                int b0=b-1; //создаем переменную равную индексу элемента на один меньше
                int b1=b+1; //создаем переменную равную индексу элемента на один больше
                ui->table_with_values_array->item(b, 0)->setBackground(Qt::green);  //выделяем ячейку со значением найденного элемента
                if (!scrol) //если к ошибке не прокручивалось
                {
                    ui->table_with_values_array->scrollToItem(ui->table_with_values_array->item(b,0)); //прокручиваем к первой ошибке
                }
                count++;   //увеличиваем количество найденных значений на один
                QString str;    //создаем строковую переменную
                str.setNum(b+1);    //добавляем ей значение номера ячейки преобразованного в строку
                tablment(&str); //добавляем в таблицу строку элемента

                while((qFuzzyCompare(mas[b1],search))||(qFuzzyCompare(mas[b0],search))) //пока будущий или предыдущий элемент равен искомому значеню
                {
                    if(qFuzzyCompare(mas[b0],search))   //если предыдущий элемент равен искомому, то увеличиваем количество найденных значений на один выделяем зеленым уветом ячейку и добавляем в комбобокс значение номера ячейки
                    {
                        count++;
                        QString str;
                        ui->table_with_values_array->item(b0, 0)->setBackground(Qt::green);
                        str.setNum(b0+1);
                        tablment(&str); //добавляем в таблицу строку элемента
                    }
                    if (qFuzzyCompare(mas[b1],search))//если следующий элемент равен искомому, то увеличиваем количество найденных значений на один выделяем зеленым уветом ячейку и добавляем в комбобокс значение номера ячейки
                    {
                        count++;
                        QString str;
                        ui->table_with_values_array->item(b1, 0)->setBackground(Qt::green);
                        str.setNum(b1+1);
                        tablment(&str); //добавляем в таблицу строку элемента
                    }
                    b0--;
                    b1++;
                }
            }
        }
        ui->label_meaning_answer_of_number_of_occurences->setNum(count);    //выводим кол-во нахождений
        searched = false;   //переменной поиска присваиваем значение ложь так как поиск не совершается
        delete [] mas;  //удаляем массив
        mas=nullptr;    //зануляем указатель
        counting = false;   //измененияя вызванные поиском закончились
    }
    else
    {
        QMessageBox::information(this, "Ошибка", "Выберите проект работы с динамическим массивом");
    }
}

void MainWindow::on_press_button_delete_dublicates_clicked() //удаление дубликатов
{
    if (dinamic_program)
    {
        if(sorted)    //если массива отсортирован
        {
            bool error = false; //создаем переменную для проверки корректности прочтения данных с таблицы
            double *mas = new double[size]; //создаем массив
            read_array(mas,size,&error); //считываем массив
            if(error)   //если таблица была заполнена неккоректно то выдает ошибку, удаляет массив, зануляет указатель и выходит из функции
            {
                QMessageBox::information(this, "Ошибка", "Таблица заполнена некорректно!");
                delete [] mas;
                mas=nullptr;
                return;
            }
            int count  = 0;   //индекс для элементов без дубликатов
            for (int i = 1;i<size;i++)    //проходим по всему массив
            {
                if(!qFuzzyCompare(mas[i],mas[i-1]))   //если предыдущий элемент не равен текущему
                {
                    count+=1; //индекс элементов без дубликатов увеличиваем на один
                    mas[count]=mas[i];    //элементу, по  индексу равный индексу увеличенному на один присваиваем значение текущего элемента, который неравен предыдущему
                }
            }
            ui->spin_row_value_tables->setValue(count+1); //удаляем не нужные ячейки таблицы
            write_array(mas,count+1); //выводим массив на таблицу
            delete [] mas;    //удаляем массив
            mas = nullptr;    //зануляем указатель
        }else //иначе, когда массив не отсортирован выводим ошибку
        {
            QMessageBox::information(this,"Ошибка","Вы не отсортировали массив",QMessageBox::Ok); //выводим сообщение об ошибке
        }
        ui->label_meaning_answer_of_number_of_occurences->clear();  //очищаем знаечение значение чейки которая показывает кол-во найденных значеений
        ui->label_meaning_rare_value->clear(); //очищает значение вывода самого редкого числа найденного в массиве
        ui->table_count->setRowCount(size_of_count = 0);//очищаем таблицу вывода
        size_of_count=0;
        //    int new_size =1 ;
        //    double *array = new double[new_size];
        //    array[0]=mas[0];
        //    for(int i = 1; i<size;i++)
        //    {
        //        if (!qFuzzyCompare(mas[i],mas[i-1]))
        //        {
        //            new_size+=1;
        //            array[new_size-1]=mas[i];
        //        }
        //    }
        //    ui->spin_row_value_tables->setValue(new_size);
        //    write_array(array,new_size);
        //    ui->label_max_answer->setNum(new_size);
        //    delete [] mas;
        //    mas=nullptr;
        //    delete [] array;
        //    array = nullptr;
    }
    else
    {
        QMessageBox::information(this, "Ошибка", "Выберите проект работы с динамическим массивом");
    }
}

void MainWindow::on_lineEdit_of_search_textEdited(const QString &arg1)  //изменение данных в строке поиска
{
    if (dinamic_program)
    {
        ui->table_count->setRowCount(size_of_count = 0);//очищение таблицы с найденными значениями
        ui->label_meaning_answer_of_number_of_occurences->clear();  //очищение строки с количество нахождений
        bool error = false; //создаем переменную ошибки чтоб можно было вызвать функцию чтения массива и изменить цвет ячеек которые были найденны ранее
        double *mas = new double[size]; //создаем массив
        read_array(mas,size,&error);    //вызываем функцию считывания
        delete [] mas;  //удаляем массив
        mas = nullptr;  //зануляем указатель
        // второй способ
        //on_press_button_search_clicked();  // вызываем функцию поиск при какждом изменении числа в строке ввода искомого значения
        Q_UNUSED(arg1) // указываем что данная переменная не используется в функции
    }
    else
    {
        ui->lineEdit_of_search->setText("");
        QMessageBox::information(this, "Ошибка", "Выберите проект работы с динамическим массивом");
    }
}

void MainWindow::on_pushButton_const_clicked()  //ввод константы
{
    if (dinamic_program or geometry_program)
    {
        consting = true;    //показывает что последующие ихменения вызваны заполнением константой всех ячеек
        ui->table_count->setRowCount(size_of_count = 0);//очищает таблицу найденных значений
        ui->label_answer_perimeter->clear();
        ui->label_answer_square->clear();
        bool ok;    // создаем переменную для проверки корректности введенного в строку поиска
        int sconst = ui->lineEdit_const->text().toInt(&ok);   //считывание введенного в строку константы значения и перевод в  число
        if (!ok) // если преобразование прошло неккоректно то выдаем ошибку и выходим из функции
        {
            QMessageBox::information(this, "Ошибка", "Некорреткное вводимое значение!"); //вывод сообщения что пользователем было введено неправильное значение
            consting = false;   //изменения вызываемые функцией вводящей константу во все значения закончились
            return; //возврат
        }
        double *mas = new double[size]; //создаем массив
        for (int i=0; i<size;i++)//создаем цикл
        {   //считываем значение ячеек
            QTableWidgetItem *item = ui->table_with_values_array->item(i,0);    //создаем указатель на память выделенную ячейкой
            if(item==nullptr)   //если память не была выделена
            {
                item = new QTableWidgetItem;    //выделяем память
                ui->table_with_values_array->setItem(i, 0, item);   //присваиваем ячейке выделенную пустую память по указателю
            }

            item->setBackground(Qt::white); //даем ячейке белый фон
            QString str;    // создаем строку
            str.setNum(sconst); //даем присваиваем строке преобразованное значение введе
            item->setText(str); //присваиваем элементу значение строки
        }
        delete [] mas;  //удаляем массив
        mas = nullptr;  //зануляем указатель
        if (ui->table_with_values_array->columnCount()==2)
        {
            double *mas = new double[size]; //создаем массив
            for (int i=0; i<size;i++)//создаем цикл
            {   //считываем значение ячеек
                QTableWidgetItem *item = ui->table_with_values_array->item(i,1);    //создаем указатель на память выделенную ячейкой
                if(item==nullptr)   //если память не была выделена
                {
                    item = new QTableWidgetItem;    //выделяем память
                    ui->table_with_values_array->setItem(i, 1, item);   //присваиваем ячейке выделенную пустую память по указателю
                }

                item->setBackground(Qt::white); //даем ячейке белый фон
                QString str;    // создаем строку
                str.setNum(sconst); //даем присваиваем строке преобразованное значение введе
                item->setText(str); //присваиваем элементу значение строки
            }
            delete [] mas;  //удаляем массив
            mas = nullptr;  //зануляем указатель
        }
        consting = false;   //указываем что изменения вызываемые вводом константы закончились
    }
    else
    {
        QMessageBox::information(this, "Ошибка", "Выберите проект работы с динамическим массивом");
    }

}

void MainWindow::tablment(QString *str) //добавление элемента в таблицу найденых значений поиска
{

    size_of_count+=1;   // размер таблицы вывода строк +1
    ui->table_count->setRowCount(size_of_count);    // даем таблице вывода обновленное кол-во строк
    QTableWidgetItem *item = ui->table_count->item(size_of_count-1,0);    //создание указателя на память в которой хранятся значения ячейки
    if(item == nullptr) // если память на значение ячейки не была выделена
    {
        item = new QTableWidgetItem;    //выделяем память для указателя
        ui->table_count->setItem(size_of_count-1, 0, item);   //устанавливаем в значение ячейки указатель
    }
    item->setText(*str);    //вывод строки в значение текущей ячейки

}

void MainWindow::on_table_count_itemChanged(QTableWidgetItem *item) //изменение в ячейке таблицы вывода строк с найденным значением
{
    if (dinamic_program)
    {
        if(!counting)   //если вызвана не поиском
        {
            on_press_button_search_clicked(); //вызов поиска
            Q_UNUSED(item); // ячейка не используется
        }
    }
}

void MainWindow::on_button_work_with_dinamic_array_clicked(bool checked)    // кнопка работы с динмаическим массивом нажата
{
    dinamic_program=checked;
    if (dinamic_program)
    {
        geometry_program=false;
        ui->spin_row_value_tables->setMinimum(0);
        ui->spin_row_value_tables->setValue(0);
        ui->table_with_values_array->setRowCount(0);
        ui->table_with_values_array->setColumnCount(1); //даем кол-ву колонок значение один
        ui->spin_row_value_tables->setMaximum(1000000); //ставим ограничение на кол-во строк
        ui->table_count->setColumnCount(1); // даем кол-ву колонок в таблице вывода строк один
    }
}

void MainWindow::on_lineEdit_const_textEdited(const QString &arg1)  //если изменили текст в строке ввода константы
{
    if(!dinamic_program and !geometry_program)
    {
        ui->lineEdit_const->setText("");
        QMessageBox::information(this, "Ошибка", "Выберите проект");
    }
    Q_UNUSED(arg1);
}

void MainWindow::on_button_work_with_geom_clicked(bool checked) //если выбран проект работы с многоугольниками
{
    geometry_program = checked;
    if(geometry_program)
    {
        dinamic_program = false;
        ui->table_with_values_array->setRowCount(0); //опустошаем старые значения
        ui->spin_row_value_tables->setMinimum(3); //ставим ограничение на минимальное количество трех стро
        ui->spin_row_value_tables->setValue(3); // создаем три строки
        ui->spin_row_value_tables->setMaximum(200); // ставим ограничение на максимальное кол-во строк
        ui->table_with_values_array->setColumnCount(2); //создаем два столбца
        ui->label_max_answer->clear(); //очищает значение максимального числа в массиве
        ui->label_mean_answer->clear(); //очищает значение среднего числа в массиве
        ui->label_min_answer->clear();  //очищает значение минимального числа в массиве
        ui->label_meaning_answer_of_number_of_occurences->clear();  //очищает значение кол-ва найденных элементов при поиске
        ui->table_count->setRowCount(size_of_count = 0);//очищает таблицу найденных значений
        ui->lineEdit_const->setText("");    // удаляем возможно введенные пользователем значения в строку поиска
        ui->lineEdit_of_search->setText(""); // удаляем возможно введенные пользователем значения в строку ввода константы
    }
}

void MainWindow::on_pushButton_calculate_clicked() // если нажата кнопка поиска площади фигуры
{
    if(geometry_program)
    {
        double point_x[200]; // allocating memory for array for x values
        double point_y[200]; // allocating memory for array for y values
        int rows = ui->table_with_values_array->rowCount(); // number of rows
        bool error = false; // allocating memory for bool in order to use if there are mistakes in future
        for(int i=0; i < rows; i++)
        {
            QTableWidgetItem *Item = ui->table_with_values_array->item(i,0); // allocate memory and creating pointer to memory
            if(Item == nullptr) // checking if nothing is entered in the cell
            {
                Item = new QTableWidgetItem; // allocating memory for empty item
                ui->table_with_values_array->setItem(i,0,Item); // add empty item to place of item in tablewidget,which return nullptr
            }
            QString str = Item->text(); // allocate memory for sting and assign a value of item
            bool flag; //allocate memory for flag to use for cheaking correctness of double conversion
            double value = str.toDouble(&flag); // allocate memory for double value of str and cheaking corectness of conversion string to double
            if(flag)
            {
                point_x[i] = value;
            } else
            {
                error = true; // give value true because there is error
            }
            Item = ui->table_with_values_array->item(i,1);//similarly past
            if(Item == nullptr)
            {
                Item = new QTableWidgetItem;
                ui->table_with_values_array->setItem(i,1,Item);
            }
            str = Item->text();
            value = str.toDouble(&flag);
            if (flag)
            {
                point_y[i]=value;
            }
            else
            {
                error=true;
            }
        }
        if(error)// cheaking mistakes
        {
            ui->label_answer_perimeter->clear();
            ui->label_answer_square->clear();
            QMessageBox::information(this, "Ошибка", "Введены некорректные данные!",QMessageBox::Ok);//pop-ups message if there was mistake
        }
        else
        {   //loking for a perimeter
            double perimeter = 0.0; // allocate memory for perimeter value and give value
            for(int i=0; i<rows; i++)
            {
                int next=i+1;// allocate memory for next value i and give value
                if (next == rows)
                {
                    next=0; // the figure closes
                }
                double x1 = point_x[i]; // allocate memory for  x1 coordinate point and assign it a value
                double x2 = point_x[next]; // allocate memory for  x2 coordinate point and assign it a value
                double y1 = point_y[i]; //allocate memory for y1 coordinate point and assign it a value
                double y2 = point_y[next]; // allocate memory for y3 coordinate point and assign value
                double distance = sqrt(pow(x2 - x1, 2) + pow(y2 - y1, 2)); // allocate memory for distance, search and assign a value
                perimeter += distance; // adding a side value to the perimeter value
            }

            if(qIsInf(perimeter) or qIsNaN(perimeter))  //проверка на бесконечность ии нечисло
            {
                QMessageBox::information(this,"Ошибка вычисления периметра","Переполнение или не является числом",QMessageBox::Ok);  //выводим пользователю ошибку

            }else
            {
                ui->label_answer_perimeter->setNum(perimeter);
            }
            // end looking for a perimeter
            //cheking for intersection
            bool intersection = false;
            if (rows < 3)
            {
                QMessageBox::information(this, "Ошибка", "Это не многоугольник",QMessageBox::Ok);//pop-ups message if there was mistake
                intersection =true;
            }
            for(int j = 0; j < rows - 2; j++){
                double k_1 = 0.0, b_1 = 0.0;
                if(qFuzzyCompare(point_x[j+1], point_x[j])){   //берем первый отрезок если он не нулевой
                    k_1 = 0;
                    b_1 = point_y[j] - k_1 * point_x[j];
                }
                else{ // если нулевой
                    k_1 = (point_y[j+1] - point_y[j]) / (point_x[j+1] - point_x[j]);
                    b_1 = point_y[j] - k_1 * point_x[j];
                }
                for(int i = j+2; i < rows; i++){  //берем третий отрезок и последующие
                    double k_2=0.0, b_2=0.0, w=0.0;
                    if(point_x[i+1] - point_x[i] == 0.0){
                        k_2 = 0;
                        b_2 = point_y[i] - k_2 * point_x[i];
                    }
                    else{ //если нулевой
                        k_2 = (point_y[i+1] - point_y[i]) / (point_x[i+1] - point_x[i]);
                        b_2 = point_y[i] - k_2 * point_x[i];
                    }
                    if(k_1 == 0.0 && k_2 == 0.0){   //если оба коэффицента равны нулю то прямые горизонтальные
                        // прямые либо вертикальные либо горизонтальные
                    }
                    else if(k_1 - k_2 == 0.0){ //иначе если оба рав то прямые паралелльны
                        // к равны то есть прямые параллельны
                    }
                    else //если не паралельны и не горизонтальны
                    {
                        w = (b_2 - b_1) / (k_1 - k_2);
                        if (((qMin(point_x[j], point_x[j+1]) < w) && (w < qMax(point_x[j], point_x[j+1]))) && ((qMin(point_x[i], point_x[i+1]) < w)&&(w < qMax(point_x[i], point_x[i+1])))) //проверяем на пересечение
                        {
                            //отрезки пересекаются
                            if(!intersection)
                            {
                                QMessageBox::information(this,"Ошибка","Площадь посчитать невозможно так как отрезки пересекаются.",QMessageBox::Ok);
                            }
                            intersection=true;
                        }
                    }
                }
            }
            //end cheking for intersecrion
            if (!intersection)  //ессли пересечений нет товычисляем площадь
            {
                double square;
                double sum_1, last_1, sum_2, last_2;
                sum_1 = 0;
                sum_2 = 0;
                last_1 = point_x[rows-1]*point_y[0];
                last_2 = point_x[0]*point_y[rows-1];

                for(int i = 0; i < rows-1; i++){
                    sum_1 += point_x[i]*point_y[i+1];
                }
                for(int i = 1; i < rows; i++){
                    sum_2 += point_x[i]*point_y[i-1];
                }

                square = 0.5 * abs(sum_1 + last_1 - sum_2 - last_2);
                if(qIsInf(square) or qIsNaN(square))  //проверка на бесконечность или нечисло
                {
                    QMessageBox::information(this,"Ошибка вычисления площади","Переполнение или не является числом",QMessageBox::Ok);  //выводим пользователю ошибку

                }else
                {
                    ui->label_answer_square->setNum(square); // вывести площадь
                }

            }
        }
    }
    else
    {
        QMessageBox::information(this, "Ошибка", "Выберите проект работы с многоугольниками");
    }
}

void MainWindow::on_pushButton_rare_value_clicked() // поиск самого редкого числа в массиве
{
    if (dinamic_program)
    {
        //создаем сортированный массив и выводим ошибку при некорректно введенных данных в таблицу
        bool error = false; //создаем переменную для проверки корректности прочтения данных с таблицы
        double *mas = new double[size]; //создаем массив
        on_press_button_fast_clicked();
        read_array(mas,size,&error); //считываем массив
        if(error)   //если таблица была заполнена неккоректно то выдает ошибку, удаляет массив, зануляет указатель и выходит из функции
        {
            delete [] mas;
            mas=nullptr;
            return;
        }

        // находим самое редкое число
        double answer = mas[0];
        int counter = INFINITY;
        int new_counter = 1;
        int flag = 0;
        for(int i = 1;i < size;i++)
        {
            new_counter+=1;
            if(mas[i-1]!=mas[i])
            {
                if(new_counter==counter)
                {

                    counter = new_counter;
                    answer = mas[i-1];
                    flag += 1; // показываем что существует две редких переменных
                }
                if(new_counter < counter)
                {
                    counter = new_counter;
                    answer = mas[i-1];
                    flag = 0;
                }
                if(flag > 0)
                {
                    if(flag == 1) // если редкая переменная была найдна в прошлый раз то  мы добавляем предыдщий ответ так как его количество нахождений тоже самое что и ответа найденного сейчас
                    {
                        QString ans;
                        ans.setNum(mas[i-2]);
                        counting = true;
                        tablment(&ans);
                        counting=false;
                    }
                    QString ans;
                    ans.setNum(answer);
                    counting = true;
                    tablment(&ans);
                    counting=false;
                }else
                {
                    size_of_count = 0;
                }

                if(i==size-1)
                {
                    answer = mas[i];
                    if(flag > 0)
                    {
                        QString ans;
                        ans.setNum(answer);
                        counting = true;
                        tablment(&ans);
                        counting=false;
                    }
                }

                new_counter = 1;
            }

        }
        if (flag == 0)
        {
            ui->label_meaning_rare_value->setNum(answer);
        } else
        {
            ui->label_meaning_rare_value->setText("Ответов несколько, поэтому они выведенны в таблицу 'Номера строк'");
        }

        delete [] mas;
        mas=nullptr;
    }
    else
    {
        QMessageBox::information(this, "Ошибка", "Выберите проект работы с динамическим массивом");
    }
}



